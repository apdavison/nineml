#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import nineml
from nineml.abstraction_layer.testing_utils import RecordValue, TestableComponent
from nineml.abstraction_layer import ComponentClass
from nineml.abstraction_layer.testing_utils import std_pynn_simulation
import os, sys, math
import numpy.random
from time import localtime, strftime, time
import expression_parser
import units_parser
from daetools.pyDAE import *

class identifierValue(object):
    """
    Internal class to wrap identifiers' values (can be numerical values or callable objects).
    """
    def __init__(self, value):
        self.value = value
        
    def __float__(self):
        """
        Achtung!! This makes identifierValue objects behave like numbers.
        """
        if isinstance(self.value, (long, int, float)):
            return float(self.value)
        
        else: # Is callable
            return float(self.value())
    
    def __str__(self):
        return '{0}'.format(self.__float__())
    
    def __repr__(self):
        return 'identifierValue({0})'.format(self.value)
    
def addIdentifiers(model, parent, dictIdentifiers):
    """
    Adds all identifiers (parameters, variables, inlet analogue ports) to the dictionary dictIdentifiers.
    This function is used to parse mathematical equations and conditional expressions and create
    daetools equation residual objects.
    Dictionary keys are relative canonical names (relative to the 'parent' model). For instance, if
    the canonical name of the 'model' is 'model1.model2.param1' and the canonical name of the 'parent'
    is 'model1' then the relative name is 'model2.param1' (the equations can access that parameters
    by using the identifier 'model2.param1').
    Dictionary values are daetools 'adouble' objects obtained by calling the function call operator
    of parameters (daeParameter class) and variables (daeVariable class). adouble class defines all standard 
    mathematical and logical operators and all standard mathematical functions (sqrt, exp, log, sin, cos, ...)
    so that the AST generated from the NineML expressions can be evaluated and equation residuals and
    logical expressions be constructed.
    
    :param model: nineml_daetools_bridge object
    :param parent: daeModel-derived object
    :param dictIdentifiers: python dictionary 'relative name' : adouble object
        
    :rtype: python dictionary (modified dictIdentifiers argument)
    :raises: RuntimeError
    """
    if not model:
        return dictIdentifiers
    
    for o in model.Parameters:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = o()

    for o in model.Variables:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = o()

    # Inlet analog ports do not have corresponding variable in the model (state or alias)
    # Outlet ports do have
    # Reduce ports have one that is generated by ninemlReduceAnalogPort class
    for port in model.nineml_analog_ports:
        if port.Type == eInletPort:
            if len(port.Variables) != 1:
                raise RuntimeError('Number of variables has to be 1, in the port ' + port.CanonicalName)
            relName = daeGetRelativeName(parent, port)
            #print('CanonicalName: {0}, RelName: {1}'.format(port.CanonicalName, relName))
            dictIdentifiers[relName] = port.Variables[0]()

    for m in model.Models:
        dictIdentifiers = addIdentifiers(m, model, dictIdentifiers)

    return dictIdentifiers

def addIdentifiersValues(model, parent, dictIdentifiers):
    """
    Identical to the function *addIdentifiers* except that it adds *identifierValue* objects 
    (and not *adouble* objects) which implement __float__ function so that they can be evaluated. 
    This function is used during initialization step when parsing expressions used to set parameters 
    values and initial conditions (to evaluate a value of an expression). It adds a callable object for 
    parameters'/variables' because values ain't initialized yet at this point.
    
    **Achtung!!** Some values might not be evaluated yet. Perhaps the values with simple numbers should 
    be set first and then expressions that depend on them evaluated.
    
    :param model: nineml_daetools_bridge object
    :param parent: daeModel-derived object
    :param dictIdentifiers: python dictionary 'relative name' : identifierValue object
        
    :rtype: python dictionary (modified dictIdentifiers argument)
    :raises: RuntimeError
    """
    if not model:
        return dictIdentifiers
    
    for o in model.Parameters:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = identifierValue(o.GetValue)

    for o in model.Variables:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = identifierValue(o.GetValue)

    # Inlet analog ports do not have corresponding variable in the model (state or alias)
    # Outlet ports do have
    # Reduce ports have one that is generated by ninemlReduceAnalogPort class
    if hasattr(model, 'nineml_analog_ports'):
        for port in model.nineml_analog_ports:
            if port.Type == eInletPort:
                if len(port.Variables) != 1:
                    raise RuntimeError('Number of variables has to be 1, in the port ' + port.CanonicalName)
                relName = daeGetRelativeName(parent, port)
                #print('CanonicalName: {0}, RelName: {1}'.format(port.CanonicalName, relName))
                dictIdentifiers[relName] = identifierValue(port.Variables[0].GetValue)

    for m in model.Models:
        dictIdentifiers = addIdentifiersValues(m, model, dictIdentifiers)

    return dictIdentifiers
    
class ninemlRNG(object):
    uniform     = 0
    normal      = 1
    binomial    = 2
    poisson     = 3
    exponential = 4
    
    def __init__(self, distribution, **kwargs):
        self.distribution = distribution
        self.rng          = numpy.random.RandomState()
        self.seed         = kwargs.get('seed', None)
        if self.seed:
            self.rng.seed(self.seed)
        
        if self.distribution == ninemlRNG.uniform:
            self.lowerBound = kwargs.get('lowerBound')
            self.upperBound = kwargs.get('upperBound')
        
        elif self.distribution == ninemlRNG.normal:
            self.centre = kwargs.get('centre')
            self.width  = kwargs.get('width')
        
        elif self.distribution == ninemlRNG.binomial:
            self.n = kwargs.get('n')
            self.p = kwargs.get('p')
        
        elif self.distribution == ninemlRNG.poisson:
            self.lamb = kwargs.get('lamb')
        
        elif self.distribution == ninemlRNG.exponential:
            self.beta = kwargs.get('beta')
        
        else:
            raise RuntimeError('Unsupported random distribution: {0}'.format(str(distribution)))
   
    def next(self):
        res = [0.0]
        if self.distribution == ninemlRNG.uniform:
            res = self.rng.uniform(self.lowerBound, self.upperBound, 1)
        
        elif self.distribution == ninemlRNG.normal:
            res = self.rng.normal(self.centre, self.width)
        
        elif self.distribution == ninemlRNG.binomial:
            res = self.rng.binomial(self.n, self.p)
        
        elif self.distribution == ninemlRNG.poisson:
            res = self.rng.poisson(self.lamb)
        
        elif self.distribution == ninemlRNG.exponential:
            res = self.rng.exponential(self.beta)
        
        return float(res[0])
        
    @classmethod
    def create_rng(cls, al_component, parameters):
        """
        Creates numpy RNG based on the AL Component object and parameters from the UL component. 
        
        :param cls: ninemlRNG class
        :param al_component: AL Component object
        :param parameters: python dictionary 'name' : (value, units)
        
        :rtype: ninemlRNG object
        :raises: RuntimeError
        """
        if al_component.name == 'uniform_distribution':
            lowerBound = parameters['lowerBound'][0]
            upperBound = parameters['upperBound'][0]
            rng = ninemlRNG(ninemlRNG.uniform, lowerBound = lowerBound, upperBound = upperBound, seed = None)
        
        elif al_component.name == 'normal_distribution':
            centre = parameters['centre'][0]
            width  = parameters['width'][0]
            rng = ninemlRNG(ninemlRNG.normal, centre = centre, width = width, seed = None)
        
        elif al_component.name == 'binomial_distribution':
            n = parameters['n'][0]
            p = parameters['p'][0]
            rng = ninemlRNG(ninemlRNG.binomial, n = n, p = p, seed = None)
        
        elif al_component.name == 'poisson_distribution':
            lamb = parameters['lamb'][0]
            rng = ninemlRNG(ninemlRNG.poisson, lamb = lamb, seed = None)
        
        elif al_component.name == 'exponential_distribution':
            beta = parameters['beta'][0]
            rng = ninemlRNG(ninemlRNG.exponential, beta = beta, seed = None)
        
        else:
            raise RuntimeError('Unsupported random distribution component: {0}'.format(al_component.name))

        return rng

_global_rng_ = numpy.random.RandomState()

def random_uniform(lowerBound = 0.0, upperBound = 1.0):
    res = _global_rng_.uniform(lowerBound, upperBound, 1)
    return float(res[0])

def random_normal(centre = 0.0, width = 1.0):
    res = _global_rng_.normal(centre, width)
    return float(res)

def random_binomial(n, p):
    res = _global_rng_.binomial(n, p)
    return float(res)

def random_poisson(lam = 1.0):
    res = _global_rng_.poisson(lam)
    return float(res)

def random_exponential(beta = 1.0):
    res = _global_rng_.exponential(beta)
    return float(res)

def createExpressionParser():
    return expression_parser.ExpressionParser()

def getEquationsExpressionParserIdentifiers(model):
    dictIdentifiers = {}

    dictIdentifiers['pi'] = Constant(math.pi)
    dictIdentifiers['e']  = Constant(math.e)
    dictIdentifiers['t']  = Time()
    if model:
        dictIdentifiers = addIdentifiers(model, model, dictIdentifiers)
    
    return dictIdentifiers

def getEquationsExpressionParserFunctions():
    dictFunctions   = {}

    # Standard math. functions (single argument)
    dictFunctions['__create_constant__'] = Constant
    dictFunctions['sin']   = Sin
    dictFunctions['cos']   = Cos
    dictFunctions['tan']   = Tan
    dictFunctions['asin']  = ASin
    dictFunctions['acos']  = ACos
    dictFunctions['atan']  = ATan
    dictFunctions['sinh']  = Sinh
    dictFunctions['cosh']  = Cosh
    dictFunctions['tanh']  = Tanh
    dictFunctions['asinh'] = ASinh
    dictFunctions['acosh'] = ACosh
    dictFunctions['atanh'] = ATanh
    dictFunctions['log10'] = Log10
    dictFunctions['log']   = Log
    dictFunctions['sqrt']  = Sqrt
    dictFunctions['exp']   = Exp
    dictFunctions['floor'] = Floor
    dictFunctions['ceil']  = Ceil
    dictFunctions['fabs']  = Abs

    # Non-standard functions (multiple arguments)
    dictFunctions['pow']   = Pow

    # Random distributions, non-standard functions
    # Achtung!! Should be used only in StateAssignments statements
    dictFunctions['random.uniform']     = random_uniform
    dictFunctions['random.normal']      = random_normal
    dictFunctions['random.binomial']    = random_binomial
    dictFunctions['random.poisson']     = random_poisson
    dictFunctions['random.exponential'] = random_exponential

    #print(dictIdentifiers)
    #print(dictFunctions)
    return dictFunctions

def getEquationsExpressionParser(model):
    """
    Returns the ExpressionParser object needed to parse NineML mathematical and logical expressions.
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = getEquationsExpressionParserIdentifiers(model)
    dictFunctions   = getEquationsExpressionParserFunctions()
    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser

def getParametersValuesInitialConditionsExpressionParserIdentifiers(model):
    dictIdentifiers = {}
    dictIdentifiers['pi'] = math.pi
    dictIdentifiers['e']  = math.e
    if model:
        dictIdentifiers = addIdentifiers(model, model, dictIdentifiers)
    return dictIdentifiers

def getParametersValuesInitialConditionsExpressionParserFunctions():
    dictFunctions   = {}
    
    # Standard math. functions (single argument)
    dictFunctions['__create_constant__'] = float
    dictFunctions['sin']   = math.sin
    dictFunctions['cos']   = math.cos
    dictFunctions['tan']   = math.tan
    dictFunctions['asin']  = math.asin
    dictFunctions['acos']  = math.acos
    dictFunctions['atan']  = math.atan
    dictFunctions['sinh']  = math.sinh
    dictFunctions['cosh']  = math.cosh
    dictFunctions['tanh']  = math.tanh
    dictFunctions['asinh'] = math.asinh
    dictFunctions['acosh'] = math.acosh
    dictFunctions['atanh'] = math.atanh
    dictFunctions['log10'] = math.log10
    dictFunctions['log']   = math.log
    dictFunctions['sqrt']  = math.sqrt
    dictFunctions['exp']   = math.exp
    dictFunctions['floor'] = math.floor
    dictFunctions['ceil']  = math.ceil
    dictFunctions['fabs']  = math.fabs
    # Non-standard functions (multiple arguments)
    
    dictFunctions['pow']   = math.pow
    return dictFunctions
    
def getParametersValuesInitialConditionsExpressionParser(model):
    """
    Returns the ExpressionParser object needed to parse the expressions for parameters' values 
    and initial conditions:    
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = getParametersValuesInitialConditionsExpressionParserIdentifiers(model)
    dictFunctions   = getParametersValuesInitialConditionsExpressionParserFunctions()
    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser
    
def getAnalogPortsExpressionParser():
    """
    Returns the ExpressionParser object needed to parse inputs for the analogue ports:
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = {}
    dictFunctions   = {}

    dictIdentifiers['pi'] = math.pi
    dictIdentifiers['e']  = math.e

    # Standard math. functions (single argument)
    dictFunctions['sin']   = math.sin
    dictFunctions['cos']   = math.cos
    dictFunctions['tan']   = math.tan
    dictFunctions['asin']  = math.asin
    dictFunctions['acos']  = math.acos
    dictFunctions['atan']  = math.atan
    dictFunctions['sinh']  = math.sinh
    dictFunctions['cosh']  = math.cosh
    dictFunctions['tanh']  = math.tanh
    dictFunctions['asinh'] = math.asinh
    dictFunctions['acosh'] = math.acosh
    dictFunctions['atanh'] = math.atanh
    dictFunctions['log10'] = math.log10
    dictFunctions['log']   = math.log
    dictFunctions['sqrt']  = math.sqrt
    dictFunctions['exp']   = math.exp
    dictFunctions['floor'] = math.floor
    dictFunctions['ceil']  = math.ceil
    dictFunctions['fabs']  = math.fabs

    # Non-standard functions (multiple arguments)
    dictFunctions['pow']   = math.pow

    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser

def printComponent(c, name, indent_string = '  ', level = 0):
    """
    Mickey Mice function to print AL component to stdout.
    
    :param c: AL Component object
    :param name: string
    :param indent_string: string
    :param level: integer
        
    :rtype: None
    :raises:
    """
    indent = level*indent_string
    print(indent + '+ COMPONENT: [{0}], class: [{1}]'.format(name, c.__class__.__name__))

    indent = indent + '  '

    print(indent + 'parameters:')
    for o in c.parameters:
        print(indent + indent_string, o)

    print(indent + 'state_variables:')
    for o in c.state_variables:
        print(indent + indent_string, o)

    print(indent + 'aliases:')
    for o in c.aliases:
        print(indent + indent_string, o)

    print(indent + 'regimes:')
    for o in c.regimes:
        print(indent + indent_string, o)

        print(indent + indent_string + 'transitions:')
        for t in o.on_conditions:
            print(indent + 2*indent_string + 'source_regime.name: ' + t.source_regime.name)
            print(indent + 2*indent_string + 'target_regime.name: ' + t.target_regime.name)
            print(indent + 2*indent_string + 'trigger: ' + t.trigger.rhs)
            print(indent + 2*indent_string + 'state_assignments:')
            for sa in t.state_assignments:
                print(indent + 3*indent_string + sa.lhs + ' = ' + sa.rhs)
            print(indent + 2*indent_string + 'event_outputs:')
            for eo in t.event_outputs:
                print(indent + 3*indent_string + str(eo))
                
        for t in o.on_events:
            print(indent + 2*indent_string + 'src_port_name: ' + t.src_port_name)
            print(indent + 2*indent_string + 'source_regime_name: ' + t.source_regime.name)
            print(indent + 2*indent_string + 'target_regime_name: ' + t.target_regime.name)
            print(indent + 2*indent_string + 'state_assignments:')
            for sa in t.state_assignments:
                print(indent + 3*indent_string + sa.lhs + ' = ' + sa.rhs)
            print(indent + 2*indent_string + 'event_outputs:')
            for eo in t.event_outputs:
                print(indent + 3*indent_string + str(eo))


    print(indent + 'analog_ports:')
    for o in c.analog_ports:
        print(indent + indent_string, o)

    print(indent + 'event_ports:')
    for o in c.event_ports:
        print(indent + indent_string, o)

    print(indent + 'portconnections:')
    for o in c.portconnections:
        print(indent + indent_string + ' {0} -> {1}'.format(o[0].getstr('.'), o[1].getstr('.')))

    print(indent + 'subnodes:')
    for name, subc in list(c.subnodes.items()):
        printComponent(subc, name, indent_string, level+1)

def findObjectInModel(model, name, **kwargs):
    """
    Looks for and returns the object with the 'name' in the daeModel-derived object 'model'.
    
    :param model: daeModel-derived object
    :param name: string
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    look_for_domains     = kwargs.get('look_for_domains',     False)
    look_for_parameters  = kwargs.get('look_for_parameters',  False)
    look_for_variables   = kwargs.get('look_for_variables',   False)
    look_for_ports       = kwargs.get('look_for_ports',       False)
    look_for_reduceports = kwargs.get('look_for_reduceports', False)
    look_for_eventports  = kwargs.get('look_for_eventports',  False)
    look_for_stns        = kwargs.get('look_for_stns',        False)
    look_for_models      = kwargs.get('look_for_models',      False)

    objects = []
    look_for_all = True

    # If any of those is set then set look_for_all to False
    if look_for_domains or look_for_parameters or look_for_variables or look_for_ports or look_for_reduceports or look_for_eventports or look_for_models or look_for_stns:
        look_for_all = False

    if look_for_all:
        objects = model.Domains + model.Parameters + model.Variables + model.Ports + model.EventPorts + model.STNs + model.Models
    else:
        if look_for_domains:
            objects = objects + model.Domains
        if look_for_parameters:
            objects = objects + model.Parameters
        if look_for_variables:
            objects = objects + model.Variables
        if look_for_ports:
            objects = objects + model.Ports
        if look_for_reduceports:
            objects = objects + model.nineml_reduce_ports
        if look_for_eventports:
            objects = objects + model.EventPorts
        if look_for_models:
            objects = objects + model.Models
        if look_for_stns:
            objects = objects + model.STNs

    mapObjects = {}
    for o in objects:
        mapObjects[o.Name] = o
    
    if name in mapObjects:
        return mapObjects[name]
    return None

def getObjectFromNamespaceAddress(rootModel, address, **kwargs):
    """
    Recursively looks for and returns the object with the name 'address' in the toplevel daeModel-derived object 'rootModel'.
    
    :param rootModel: daeModel-derived object
    :param address: AL NamespaceAddress object
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    canonicalName = '.'.join(address.loctuple)
    return getObjectFromCanonicalName(rootModel, canonicalName, **kwargs)

def getObjectFromCanonicalName(rootModel, canonicalName, **kwargs):
    """
    Recursively looks for and returns the object with the name 'address' in the toplevel daeModel-derived object 'rootModel'.

    :param rootModel: daeModel-derived object
    :param canonicalName: a 'path' to the object ('model1.model2.object')
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    relativeName = daeGetRelativeName(rootModel.CanonicalName, canonicalName)
    #print('  relativeName = {0} for root = {1} and canonicalName = {2}'.format(relativeName, rootModel.CanonicalName, canonicalName))
    listCanonicalName = relativeName.split('.')
    objectName = listCanonicalName[-1]
    objectPath = listCanonicalName[:-1]

    root = rootModel
    if len(objectPath) > 0:
        for name in objectPath:
            root = findObjectInModel(root, name, look_for_models = True)
            if root == None:
                raise RuntimeError('Could not locate object {0} in {1}'.format(name, ".".join(objectPath)))

    # Now we have the model where port should be located (root)
    # Search for the 'name' in the 'root' model (in the types of objects given in **kwargs)
    return findObjectInModel(root, objectName, **kwargs)

def fixObjectName(name):
    """
    Replaces spaces in the 'name' string with underscores and returns the modified string.
    
    :param name: string
        
    :rtype: string
    :raises:
    """
    new_name = name.replace(' ', '_')
    return new_name

dae_nineml_t = daeVariableType("dae_nineml_t", unit(), -1.0e+20, 1.0e+20, 0.0, 1e-12)

class ninemlAnalogPort(daePort):
    """
    Represents NineML analogue ports with a single variable (referred to with the 'value' daeVariable). 
    """
    def __init__(self, Name, PortType, Model, Description = ''):
        """
        :param Name: string
        :param PortType: daetools port type (eInlet, eOutlet, eInletOutlet)
        :param Model: daeModel-derived object
        :param Description: string
            
        :raises: RuntimeError
        """
        daePort.__init__(self, Name, PortType, Model, Description)

        # NineML ports always contain only one variable, and that variable is referred to by the port name
        # Here we name this variable 'value'
        self.value = daeVariable("value", dae_nineml_t, self, "")

class ninemlReduceAnalogPort(object):
    """
    A workaround around NineML reduce analogue ports (there are no reduce ports in daetools; it's done 
    by using multiple ports and creating equations that do some operations on their variables). 
    Whenever a connection to a reduce ports is requested a new ninemlAnalogPort object is created and
    connected to the requested source port. Once all connections are made a single equation that sums up
    'value' variables from all generated ports is created and added to the model.
    """
    def __init__(self, name, model):
        """
        :param name: string
        :param model: daeModel-derived object
            
        :raises: RuntimeError
        """
        self.Ports        = []
        self.Name         = name
        self.Model        = model
        self.portVariable = daeVariable(self.Name, dae_nineml_t, self.Model, "")

    def addPort(self):
        """
        Creates a new ninemlAnalogPort object (when a connection to a reduce ports is requested).
        
        :rtype: ninemlAnalogPort object
        :raises: RuntimeError
        """
        name = '{0}_{1}'.format(self.Name, len(self.Ports))
        port = ninemlAnalogPort(name, eInletPort, self.Model, '')
        self.Ports.append(port)
        return port

    def generateEquation(self):
        """
        Creates an equation that sums up 'value' variables from all generated ports.
        The equation is added to the parent model specified in the __init__ function.
        
        :rtype: ninemlAnalogPort object
        :raises: RuntimeError
        """
        eq = self.Model.CreateEquation(self.Name, "")
        varSum = adouble()
        for p in self.Ports:
            varSum = varSum + p.value()
        eq.Residual = self.portVariable() - varSum

class daetoolsVariableParameterDictionaryWrapper(object):
    """
    Dictionary-like class to wrap multidimensional parameters, variables, etc
    A workaround to save a lot of time that would be spent on creating dictionaries
    for each neurone/connection.
    """
    def __init__(self, dictIDs, current_index = None):
        """
        :param dictIDs: python dictionary 'name' : daeVariable/daeParameter; 
                        they should be distributed on a single domain.
        :param current_index: daeDEDI object
        """
        self.dictIDs       = dictIDs
        self.current_index = current_index
        
    def __contains__(self, key):
        return key in self.dictIDs

    def has_key(self, key):
        return key in self.dictIDs

    def __getitem__(self, key):
        """
        Gets the daeVariable object at the given *key* and calls *operator ()*
        with the index equal to the *current_index* argument.
        """
        obj = self.dictIDs[key]
        if isinstance(obj, adouble):
            return obj
        
        elif isinstance(obj, (daeParameter, daeVariable)):
            if self.current_index == None:
                if len(obj.Domains) > 0:
                    raise RuntimeError('')
                return obj()
            
            else:
                if len(obj.Domains) > 0:
                    return obj(self.current_index)
                else:
                    raise RuntimeError('')
        else:
            raise RuntimeError('')

__equation_parser__ = getEquationsExpressionParser(None)

class nineml_daetools_bridge(daeModel):
    """
    A wrapper around a single or hierarchical AL Component object.
    """
    
    # AL components always have a single STN with several regimes; this is a generic name for NineML STNs  
    ninemlSTNRegimesName = 'NineML_Regimes_STN'

    def __init__(self, Name, ninemlComponent, Parent = None, Description = ""):
        """
        Iterates over *Parameters*, *State variables*, *Aliases*, *Analogue ports*, *Event ports*, 
        *Sub-nodes* and *Port connections* and creates corresponding daetools objects.
        
        :param Name: string
        :param ninemlComponent: AL component object
        :param Parent: daeModel-derived object
        :param Description: string
            
        :raises: RuntimeError
        """
        #start = time()
        
        daeModel.__init__(self, Name, Parent, Description)
        
        #print('    daeModel.__init__({0}) = {1}'.format(Name, time() - start))

        start = time()

        self.ninemlComponent        = ninemlComponent
        self.nineml_parameters      = []
        self.nineml_state_variables = []
        self.nineml_aliases         = []
        self.nineml_analog_ports    = []
        self.nineml_reduce_ports    = []
        self.nineml_event_ports     = []
        self.ninemlSubComponents    = []

        # AL component may be None (useful in certain cases); therefore do not raise an exception
        if not self.ninemlComponent:
            return
        
        # 1) Create parameters
        for param in self.ninemlComponent.parameters:
            self.nineml_parameters.append( daeParameter(param.name, unit(), self, "") )

        # 2) Create state-variables (diff. variables)
        for var in self.ninemlComponent.state_variables:
            self.nineml_state_variables.append( daeVariable(var.name, dae_nineml_t, self, "") )

        # 3) Create alias variables (algebraic)
        for alias in self.ninemlComponent.aliases:
            self.nineml_aliases.append( daeVariable(alias.lhs, dae_nineml_t, self, "") )

        # 4) Create analog-ports and reduce-ports
        for analog_port in self.ninemlComponent.analog_ports:
            if analog_port.mode == 'send':
                self.nineml_analog_ports.append( ninemlAnalogPort(analog_port.name, eOutletPort, self, "") )
            elif analog_port.mode == 'recv':
                self.nineml_analog_ports.append( ninemlAnalogPort(analog_port.name, eInletPort, self, "") )
            elif analog_port.mode == 'reduce':
                self.nineml_reduce_ports.append( ninemlReduceAnalogPort(analog_port.name, self) )
            else:
                raise RuntimeError("")

        # 5) Create event-ports
        for event_port in self.ninemlComponent.event_ports:
            if event_port.mode == 'send':
                self.nineml_event_ports.append( daeEventPort(event_port.name, eOutletPort, self, "") )
            elif event_port.mode == 'recv':
                self.nineml_event_ports.append( daeEventPort(event_port.name, eInletPort, self, "") )
            else:
                raise RuntimeError("")

        # 6) Create sub-nodes
        for name, subcomponent in list(self.ninemlComponent.subnodes.items()):
            self.ninemlSubComponents.append( nineml_daetools_bridge(name, subcomponent, self, '') )

        # 7) Create port connections
        for port_connection in self.ninemlComponent.portconnections:
            #print 'try to connect {0} to {1}'.format(port_connection[0].getstr('.'), port_connection[1].getstr('.'))
            portFrom = getObjectFromNamespaceAddress(self, port_connection[0], look_for_ports = True, look_for_reduceports = True)
            portTo   = getObjectFromNamespaceAddress(self, port_connection[1], look_for_ports = True, look_for_reduceports = True)
            #print '  {0} -> {1}\n'.format(type(portFrom), type(portTo))
            connectPorts(portFrom, portTo, self)
        
        #print('    the rest = {0}'.format(time() - start))
            
    def DeclareEquations(self):
        """
        Iterates over *aliases*, *reduce analogue ports* and *regimes*, parses mathematical and logical expressions
        and generates daetools equation objects and state transition networks.
        
        :rtype: None
        :raises: RuntimeError
        """
        # Add identifiers for 
        __equation_parser__.dictIdentifiers = getEquationsExpressionParserIdentifiers(self)
        
        # 1) Create aliases (algebraic equations)
        aliases = list(self.ninemlComponent.aliases)
        if len(aliases) > 0:
            for i, alias in enumerate(aliases):
                eq = self.CreateEquation(alias.lhs, "")
                eq.Residual = self.nineml_aliases[i]() - __equation_parser__.parse_and_evaluate(alias.rhs)

        # 1a) Create equations for reduce ports (algebraic equations)
        for port in self.nineml_reduce_ports:
            port.generateEquation()

        # 2) Create regimes
        regimes         = list(self.ninemlComponent.regimes)
        state_variables = list(self.ninemlComponent.state_variables)
        if len(regimes) > 0:
            # 2a) Create STN for model
            self.STN(nineml_daetools_bridge.ninemlSTNRegimesName)

            for regime in regimes:
                # 2b) Create State for each regime
                self.STATE(regime.name)

                # 2c) Create equations for all state variables/time derivatives
                # Sometime a time_derivative equation is not given and in that case the derivative is equal to zero
                # We have to discover which variables do not have a corresponding ODE and
                # we do that by creating a map {'state_var' : 'RHS'} which initially has
                # set rhs to '0'. RHS will be set later while iterating through ODEs
                map_statevars_timederivs = {}
                for state_var in state_variables:
                    map_statevars_timederivs[state_var.name] = 0

                time_derivatives = list(regime.time_derivatives)
                for time_deriv in time_derivatives:
                    map_statevars_timederivs[time_deriv.dependent_variable] = time_deriv.rhs
                #print map_statevars_timederivs

                for var_name, rhs in list(map_statevars_timederivs.items()):
                    variable = self._findVariable(var_name)
                    if variable == None:
                        raise RuntimeError('Cannot find state variable {0}'.format(var_name))

                    # Create equation
                    eq = self.CreateEquation(var_name, "")

                    # If right-hand side expression is 0 do not parse it
                    if rhs == 0:
                        eq.Residual = variable.dt()
                    else:
                        eq.Residual = variable.dt() - __equation_parser__.parse_and_evaluate(rhs)

                # 2d) Create on_condition actions
                for on_condition in regime.on_conditions:
                    condition         = __equation_parser__.parse_and_evaluate(on_condition.trigger.rhs)
                    switchTo          = on_condition.target_regime.name
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_condition.state_assignments:
                        variable   = getObjectFromCanonicalName(self, state_assignment.lhs, look_for_variables = True)
                        if variable == None:
                            raise RuntimeError('Cannot find variable {0}'.format(state_assignment.lhs))
                        expression = __equation_parser__.parse_and_evaluate(state_assignment.rhs)
                        setVariableValues.append( (variable, expression) )

                    for event_output in on_condition.event_outputs:
                        event_port = getObjectFromCanonicalName(self, event_output.port_name, look_for_eventports = True)
                        if event_port == None:
                            raise RuntimeError('Cannot find event port {0}'.format(event_output.port_name))
                        triggerEvents.append( (event_port, Time()) )

                    # ACHTUNG!!!
                    # Check the order of switchTo, triggerEvents and setVariableValues arguments in daetools 1.2.0+!!!
                    self.ON_CONDITION(condition, switchTo          = switchTo,
                                                 setVariableValues = setVariableValues,
                                                 triggerEvents     = triggerEvents)

                # 2e) Create on_event actions
                for on_event in regime.on_events:
                    source_event_port = getObjectFromCanonicalName(self, on_event.src_port_name, look_for_eventports = True)
                    if source_event_port == None:
                        raise RuntimeError('Cannot find event port {0}'.format(on_event.src_port_name))
                    
                    switchToStates    = []
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_event.state_assignments:
                        variable   = getObjectFromCanonicalName(self, state_assignment.lhs, look_for_variables = True)
                        if variable == None:
                            raise RuntimeError('Cannot find variable {0}'.format(state_assignment.lhs))
                        expression = __equation_parser__.parse_and_evaluate(state_assignment.rhs)
                        setVariableValues.append( (variable, expression) )

                    for event_output in on_event.event_outputs:
                        event_port = getObjectFromCanonicalName(self, event_output.port_name, look_for_eventports = True)
                        if event_port == None:
                            raise RuntimeError('Cannot find event port {0}'.format(event_output.port_name))
                        triggerEvents.append( (event_port, Time()) )

                    # ACHTUNG!!!
                    # Check the order of switchTo, triggerEvents and setVariableValues arguments in daetools 1.2.0+!!!
                    self.ON_EVENT(source_event_port, switchToStates    = switchToStates,
                                                     setVariableValues = setVariableValues,
                                                     triggerEvents     = triggerEvents)
                                                 
            self.END_STN()

        # 3) Create equations for outlet analog-ports: port.value() - variable() = 0
        for analog_port in self.nineml_analog_ports:
            if analog_port.Type == eOutletPort:
                eq = self.CreateEquation(analog_port.Name + '_portequation', "")
                var_to = findObjectInModel(self, analog_port.Name, look_for_variables = True)
                if var_to == None:
                    raise RuntimeError('Cannot find variable/alias {0}'.format(analog_port.Name))
                eq.Residual = analog_port.value() - var_to()

    def _findVariable(self, name):
        for var in self.nineml_state_variables:
            if var.Name == name:
                return var
        return None

    def getSpikeInPort(self): 
        for event_port in self.nineml_event_ports:
            if event_port.Type == eInletPort:
                return event_port
                
        raise RuntimeError('{0} does not have any receive event ports'.format(self.CanonicalName))

    def getSpikeOutPort(self): 
        for event_port in self.nineml_event_ports:
            if event_port.Type == eOutletPort:
                return event_port
                
        raise RuntimeError('{0} does not have any send event ports'.format(self.CanonicalName))

def connectPorts(portInlet, portOutlet, parent_model):
    """
    Connects two analogue ports and stores the connection in the 'parent_model' object.
    
    :param portInlet: ninemlAnalogPort|ninemlReduceAnalogPort object
    :param portOutlet: ninemlAnalogPort|ninemlReduceAnalogPort object
    :param parent_model: daeModel-derived object
        
    :rtype: None
    :raises: RuntimeError
    """
    portFrom = None
    portTo   = None

    if isinstance(portInlet, ninemlAnalogPort):
        portFrom = portInlet
    elif isinstance(portInlet, ninemlReduceAnalogPort):
        portFrom = portInlet.addPort()
    else:
        raise RuntimeError('invalid portFrom')
        
    if isinstance(portOutlet, ninemlAnalogPort):
        portTo = portOutlet
    elif isinstance(portOutlet, ninemlReduceAnalogPort):
        portTo = portOutlet.addPort()
    else:
        raise RuntimeError('invalid portTo')

    parent_model.ConnectPorts(portFrom, portTo)

def connectEventPorts(portFrom, portTo, parent_model):
    """
    Connects two event ports and stores the connection in the 'parent_model' object.
    
    :param portFrom: daeEventPort object
    :param portTo: daeEventPort object
    :param parent_model: daeModel-derived object
        
    :rtype: None
    :raises: RuntimeError
    """
    if (portFrom.Type != eOutletPort) or (portTo.Type != eInletPort):
        raise RuntimeError('Cannot connect event ports: incompatible types')
    
    parent_model.ConnectEventPorts(portTo, portFrom)

def connectModelsViaEventPort(source, target, parent_model):
    """
    Connects the source and the target models via single event port and stores the connection in the 
    'parent_model' object. There must be a single outlet port in the source model and a single inlet 
    port in the target model. 
    
    :param source: nineml_daetools_bridge object (neurone)
    :param target: nineml_daetools_bridge object (target)
    :param parent_model: daeModel object (typically a network object)
        
    :rtype: None
    :raises: RuntimeError
    """
    source_port = source.getSpikeOutPort()
    target_port = target.getSpikeInPort()
    connectEventPorts(source_port, target_port, parent_model)

def connectModelsViaAnaloguePorts(source, target, parent_model):
    """
    Connects all analogue ports in the source model to all analogue ports in the target model 
    and stores the connections in the parent_model.
    The function iterates over the source ports and tries to find its match in the target ports.
    If a match is found it connects them. If a match is not found, or if an incompatible pair 
    of ports has been found it throws an exception.
    
    **ACHTUNG, ACHTUNG!!** It is assumed that sources do not have reduce ports [tamba/lamba?]
    
    :param source: nineml_daetools_bridge object (synapse)
    :param target: nineml_daetools_bridge object (neurone)
    :param parent_model: nineml_daetools_bridge object (typically a network object)
        
    :rtype: None
    :raises: RuntimeError
    """
    for source_port in source.nineml_analog_ports:
        matching_port_found = False
        
        # 1) Look in the list of analogue ports
        for target_port in target.nineml_analog_ports:
            if source_port.Name == target_port.Name:
                if (source_port.Type == eInletPort) and (target_port.Type == eOutletPort):
                    connectPorts(source_port, target_port, parent_model)
                    matching_port_found = True
                
                elif (source_port.Type == eOutletPort) and (target_port.Type == eInletPort):
                    connectPorts(source_port, target_port, parent_model)
                    matching_port_found = True
                
                else:
                    msg = 'Cannot connect a source to a neurone: source port [{0}] and neurone port [{1}] do not match'.format(source_port.Name, target_port.Name)
                    raise RuntimeError(msg)
        
        # 2) If not connected yet, look in the list of reduce ports
        if matching_port_found == False:
            for target_port in target.nineml_reduce_ports:
                if source_port.Name == target_port.Name:
                    # Achtung! Reduce ports are implicitly inlet
                    if (source_port.Type == eOutletPort):
                        connectPorts(source_port, target_port, parent_model)
                        matching_port_found = True
        
        # If not found - die miserably
        if matching_port_found == False:
            raise RuntimeError('Cannot connect a source to a neurone: cannot find a match for the source port [{0}]'.format(source_port.Name))

class daetools_spike_source(nineml_daetools_bridge):
    """
    Used to generate spikes according to the predefined sequence.
    The component has no parameters
    """
    def __init__(self, spiketimes, Name, Parent = None, Description = ""):
        nineml_daetools_bridge.__init__(self, Name, None, Parent, Description)

        # A dummy variable
        self.event = pyCore.daeVariable("event", time_t, self, "")
        
        # Add one 'send' event port
        self.spikeoutput = pyCore.daeEventPort("spikeoutput", eOutletPort, self, "Spike outlet event port")
        self.nineml_event_ports.append(self.spikeoutput)
        
        # A list of spike event times
        self.spiketimes = list(spiketimes)

    def DeclareEquations(self):
        self.stnSpikeSource = self.STN("SpikeSource")

        for i, t in enumerate(self.spiketimes):
            self.STATE('State_{0}'.format(i))
            eq = self.CreateEquation("event")
            eq.Residual = self.event() - t
            self.ON_CONDITION(Time() >= t,  switchTo      = 'State_{0}'.format(i+1),
                                            triggerEvents = [(self.spikeoutput, Time())])

        self.STATE('State_{0}'.format(len(self.spiketimes)))

        eq = self.CreateEquation("event")
        eq.Residual = self.event()

        self.END_STN()

def createPoissonSpikeTimes(rate, duration, t0, rng_poisson, lambda_, rng_uniform):
    n  = int(rng_poisson.poisson(lambda_, 1))
    spiketimes = sorted(rng_uniform.uniform(t0, t0+duration, n))
    #print(lam, n, spiketimes)
    return spiketimes

class al_component_info(object):
    """
    """
    def __init__(self, name, al_component):
        """
        Iterates over *Parameters*, *State variables*, *Aliases*, *Analogue ports*, *Event ports*, 
        *Sub-nodes* and *Port connections* and creates corresponding daetools objects.
        
        :param name: string
        :param ninemlComponent: AL component object
        :param Parent: daeModel-derived object
        :param Description: string
            
        :raises: RuntimeError
        """
        self.name                    = name
        self.al_component            = al_component
        self.nineml_parameters       = []
        self.nineml_state_variables  = []
        self.nineml_aliases          = []
        self.nineml_analog_ports     = []
        self.nineml_reduce_ports     = []
        self.nineml_event_ports      = []
        self.nineml_port_connections = []
        self.nineml_regimes          = []
        self.nineml_subcomponents    = []
        
        # AL component may be None (useful in certain cases); therefore do not raise an exception
        if not self.al_component:
            return
        
        # 1) Create parameters
        for param in self.al_component.parameters:
            self.nineml_parameters.append( (param.name, unit()) )

        # 2) Create state-variables (diff. variables)
        for var in self.al_component.state_variables:
            self.nineml_state_variables.append( (var.name, dae_nineml_t) )

        # 3) Create alias variables (algebraic) and parse rhs
        for alias in self.al_component.aliases:
            self.nineml_aliases.append( (alias.lhs, dae_nineml_t, __equation_parser__.parse(alias.rhs)) )

        # 4) Create analog-ports and reduce-ports
        for analog_port in self.al_component.analog_ports:
            if analog_port.mode == 'send':
                self.nineml_analog_ports.append( (analog_port.name, eOutletPort, dae_nineml_t) )
            elif analog_port.mode == 'recv':
                self.nineml_analog_ports.append( (analog_port.name, eInletPort, dae_nineml_t) )
            elif analog_port.mode == 'reduce':
                self.nineml_reduce_ports.append( (analog_port.name, eInletPort, dae_nineml_t) )
            else:
                raise RuntimeError("")

        # 5) Create event-ports
        for event_port in self.al_component.event_ports:
            if event_port.mode == 'send':
                self.nineml_event_ports.append( (event_port.name, eOutletPort) )
            elif event_port.mode == 'recv':
                self.nineml_event_ports.append( (event_port.name, eInletPort) )
            else:
                raise RuntimeError("")

        # 6) Create port connections
        for port_connection in self.al_component.portconnections:
            portFrom = '.'.join(port_connection[0].loctuple)
            portTo   = '.'.join(port_connection[1].loctuple)
            self.nineml_port_connections.append( (portFrom, portTo) )
        
        # 7) Create regimes
        regimes         = list(self.al_component.regimes)
        state_variables = list(self.al_component.state_variables)
        if len(regimes) > 0:
            for regime in regimes:
                odes          = []
                on_conditions = []
                on_events     = []

                # 7a) Sometime a time_derivative equation is not given and in that case a 
                # derivative is equal to zero. We have to discover which variables do not 
                # have a corresponding ODE and we do that by creating a map {'state_var' : 'RHS'} 
                # which initially has set rhs to '0'. RHS will be set later while iterating through ODEs
                map_statevars_timederivs = {}
                for state_var in state_variables:
                    map_statevars_timederivs[state_var.name] = '0'

                time_derivatives = list(regime.time_derivatives)
                for time_deriv in time_derivatives:
                    map_statevars_timederivs[time_deriv.dependent_variable] = time_deriv.rhs

                for var_name, rhs in list(map_statevars_timederivs.items()):
                    odes.append( (var_name, __equation_parser__.parse(rhs)) )
                        
                # 2d) Create on_condition actions
                for on_condition in regime.on_conditions:
                    condition         = __equation_parser__.parse(on_condition.trigger.rhs)
                    switchTo          = on_condition.target_regime.name
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_condition.state_assignments:
                        setVariableValues.append( (state_assignment.lhs, __equation_parser__.parse(state_assignment.rhs)) )

                    for event_output in on_condition.event_outputs:
                        triggerEvents.append( (event_output.port_name, 0) )

                    on_conditions.append( (condition, switchTo, setVariableValues, triggerEvents) )
                
                # 2e) Create on_event actions
                for on_event in regime.on_events:
                    source_event_port = on_event.src_port_name                    
                    switchToStates    = []
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_event.state_assignments:
                        setVariableValues.append( (state_assignment.lhs, __equation_parser__.parse(state_assignment.rhs)) )

                    for event_output in on_event.event_outputs:
                        triggerEvents.append( (event_output.port_name, 0) )

                    on_events.append( (source_event_port, switchToStates, setVariableValues, triggerEvents) )
                
                self.nineml_regimes.append( (regime.name, odes, on_conditions, on_events) )

        # 8) Create sub-nodes
        for name, subcomponent in list(self.al_component.subnodes.items()):
            self.nineml_subcomponents.append( al_component_info(name, subcomponent) )

    def __str__(self):
        res = ''
        res += 'name = {0}\n'.format(self.name)
        res += 'al_component = {0}\n'.format(self.al_component)
        res += 'nineml_parameters = {0}\n'.format(self.nineml_parameters)
        res += 'nineml_state_variables = {0}\n'.format(self.nineml_state_variables)
        res += 'nineml_aliases = {0}\n'.format(self.nineml_aliases)
        res += 'nineml_analog_ports = {0}\n'.format(self.nineml_analog_ports)
        res += 'nineml_reduce_ports = {0}\n'.format(self.nineml_reduce_ports)
        res += 'nineml_event_ports = {0}\n'.format(self.nineml_event_ports)
        res += 'nineml_port_connections = {0}\n'.format(self.nineml_port_connections)
        res += 'nineml_regimes = {0}\n'.format(self.nineml_regimes)
        for subcomponent in self.nineml_subcomponents:
            res += 'Subcomponent: {0}\n{1}\n'.format(subcomponent.name, subcomponent)
        return res
    
class dae_component(daeModel):
    def __init__(self, info, Nitems, Name, Parent = None, Description = ''):
        daeModel.__init__(self, Name, Parent, Description)
        
        self.info                           = info
        self.Nitems                         = int(Nitems)
        self.N                              = None
        self.nineml_parameters              = {}
        self.nineml_aliases                 = {}
        self.nineml_variables               = {}
        self.nineml_inlet_ports             = {}
        self.nineml_outlet_ports            = {}
        self.nineml_reduce_ports            = {}
        self.nineml_inlet_event_ports       = {}
        self.nineml_outlet_event_ports      = {}
        self.nineml_port_connections        = []
        self.nineml_reduce_port_connections = {}
        self.nineml_subcomponents           = []
        self.nineml_equations               = {}
        self.nineml_stns                    = []
        
    def initialize(self, domainN = None):
        if self.Nitems > 1:
            if domainN:
                self.N = domainN
            else:
                self.N  = daeDomain("N", self, unit(), "N domain")
            domains = [self.N]
        else:
            domains = []
        
        # 1) Create parameters
        for (name, units) in self.info.nineml_parameters:
            self.nineml_parameters[name] = daeParameter(name, units, self, "", domains)

        # 2) Create state-variables (diff. variables)
        for (name, var_type) in self.info.nineml_state_variables:
            self.nineml_variables[name] = daeVariable(name, var_type, self, "", domains)

        # 3) Create alias variables (algebraic)
        for (name, var_type, node) in self.info.nineml_aliases:
            self.nineml_aliases[name] = ( daeVariable(name, var_type, self, "", domains), node )

        # 4a) Create analog-ports
        for (name, port_type, var_type) in self.info.nineml_analog_ports:
            if port_type == eInletPort:
                self.nineml_inlet_ports[name] = daeVariable(name, var_type, self, "", domains)
            else:
                if name in self.nineml_variables:
                    self.nineml_outlet_ports[name] = self.nineml_variables[name]
                elif name in self.nineml_aliases:
                    self.nineml_outlet_ports[name] = self.nineml_aliases[name][0]
                else:
                    raise RuntimeError("")
        
        # 4b) Create reduce-ports
        for (name, port_type, var_type) in self.info.nineml_reduce_ports:
            self.nineml_reduce_ports[name] = daeVariable(name, var_type, self, "", domains)

        # 5) Create event-ports
        for (name, port_type) in self.info.nineml_event_ports:
            if port_type == eInletPort:
                self.nineml_inlet_event_ports[name]  = [ daeEventPort('{0}({1})'.format(name, i), port_type, self, "") for i in range(0, self.Nitems) ]
            else:
                self.nineml_outlet_event_ports[name] = [ daeEventPort('{0}({1})'.format(name, i), port_type, self, "") for i in range(0, self.Nitems) ]
                
        # 6) Create sub-components
        for sub_info in self.info.nineml_subcomponents:
            subcomponent = dae_component(sub_info, self.Nitems, sub_info.name, self, '')
            subcomponent.initialize(self.N)
            self.nineml_subcomponents.append(subcomponent)

        # 7) Create port connections
        inlet_ports  = self._getInletPorts(self)
        outlet_ports = self._getOutletPorts(self)
        reduce_ports = self._getReducePorts(self)
        
        # portFrom is always send, portTo is always receive/reduce
        for (nameFrom, nameTo) in self.info.nineml_port_connections:
            if (nameFrom in inlet_ports) and (nameTo in outlet_ports):
                portFrom = outlet_ports[nameTo]
                portTo   = inlet_ports [nameFrom]
                self.nineml_port_connections.append( (portFrom, portTo) )
            
            elif (nameFrom in outlet_ports) and (nameTo in inlet_ports):
                portFrom = outlet_ports[nameFrom]
                portTo   = inlet_ports [nameTo]
                self.nineml_port_connections.append( (portFrom, portTo) )

            elif (nameFrom in outlet_ports) and (nameTo in reduce_ports):
                portFrom = outlet_ports[nameFrom]
                portTo   = reduce_ports[nameTo]
                if nameTo in self.nineml_reduce_port_connections:
                    self.nineml_reduce_port_connections[nameTo][1].append(portFrom)
                else:
                    self.nineml_reduce_port_connections[nameTo] = (portTo, [portFrom])
            
            elif (nameFrom in reduce_ports) and (nameTo in outlet_ports):
                portFrom = outlet_ports[nameTo]
                portTo   = reduce_ports[nameFrom]
                if nameTo in self.nineml_reduce_port_connections:
                    self.nineml_reduce_port_connections[nameFrom][1].append(portFrom)
                else:
                    self.nineml_reduce_port_connections[nameFrom] = (portTo, [portFrom])

            else:
                raise RuntimeError('Cannot connect analogue ports {0} and {1}'.format(nameFrom, nameTo))
    
    def __str__(self):
        res = ''
        res += 'canonical_name = {0}\n'.format(self.CanonicalName)
        res += 'nineml_parameters = {0}\n'.format(self.nineml_parameters)
        res += 'nineml_variables = {0}\n'.format(self.nineml_variables)
        res += 'nineml_aliases = {0}\n'.format(self.nineml_aliases)
        res += 'nineml_inlet_ports = {0}\n'.format(self.nineml_inlet_ports)
        res += 'nineml_outlet_ports = {0}\n'.format(self.nineml_outlet_ports)
        res += 'nineml_reduce_ports = {0}\n'.format(self.nineml_reduce_ports)
        res += 'nineml_inlet_event_ports = {0}\n'.format(self.nineml_inlet_event_ports)
        res += 'nineml_outlet_event_ports = {0}\n'.format(self.nineml_outlet_event_ports)
        res += 'nineml_port_connections = {0}\n'.format(self.nineml_port_connections)
        res += 'nineml_equations = {0}\n'.format(self.nineml_equations)
        res += 'nineml_stns = {0}\n'.format(self.nineml_stns)
        for sub_comp in self.nineml_subcomponents:
            res += str(sub_comp)
        return res
    
    def connectAnaloguePorts(self, source, target):
        parent_model = self
        
        for source_variable in source.nineml_outlet_ports:
            matching_port_found = False
            
            # 1) Look in the list of inlet ports
            for target_variable in target.nineml_inlet_ports:
                if source_variable.Name == target_variable.Name:
                    parent_model.nineml_port_connections.append( (source_variable, target_variable) )
                    matching_port_found = True
            
            # 2) If not connected yet, look in the list of reduce ports
            if matching_port_found == False:
                for target_variable in target.nineml_reduce_ports:
                    if source_variable.Name == target_variable.Name:
                        if target_variable.Name in parent_model.nineml_reduce_port_connections:
                            parent_model.nineml_reduce_port_connections[target_variable.Name][1].append(source_variable)
                        else:
                            parent_model.nineml_reduce_port_connections[target_variable.Name] = (target_variable, [source_variable])
                        matching_port_found = True
            
            # If not found - die miserably
            if matching_port_found == False:
                raise RuntimeError('Cannot connect analogue ports: cannot find a match for the source port [{0}]'.format(source_variable.Name))

        for source_variable in source.nineml_inlet_ports:
            matching_port_found = False
            
            # 1) Look in the list of outlet ports
            for target_variable in target.nineml_outlet_ports:
                if source_variable.Name == target_variable.Name:
                    parent_model.nineml_port_connections.append( (source_variable, target_variable) )
                    matching_port_found = True
            
            # If not found - die miserably
            if matching_port_found == False:
                raise RuntimeError('Cannot connect analogue ports: cannot find a match for the source port [{0}]'.format(source_variable.Name))

    def _getParameters(self, parent):
        parameters = {}
        for (name, parameter) in self.nineml_parameters.iteritems():
            parameters[ daeGetRelativeName(parent, parameter) ] = parameter
        for sub_comp in self.nineml_subcomponents:
            parameters.update(sub_comp._getParameters(parent))
        return parameters

    def _getStateVariables(self, parent):
        variables = {}
        for (name, variable) in self.nineml_variables.iteritems():
            variables[ daeGetRelativeName(parent, variable) ] = variable
        for sub_comp in self.nineml_subcomponents:
            variables.update(sub_comp._getStateVariables(parent))
        return variables

    def _getAliases(self, parent):
        aliases = {}
        for (name, (alias_var, node)) in self.nineml_aliases.iteritems():
            aliases[ daeGetRelativeName(parent, alias_var) ] = alias_var
        for sub_comp in self.nineml_subcomponents:
            aliases.update(sub_comp._getAliases(parent))
        return aliases

    def _getInletPorts(self, parent):
        ports = {}
        for (name, port) in self.nineml_inlet_ports.iteritems():
            ports[ daeGetRelativeName(parent, port) ] = port
        for sub_comp in self.nineml_subcomponents:
            ports.update(sub_comp._getInletPorts(parent))
        return ports

    def _getOutletPorts(self, parent):
        ports = {}
        for (name, port) in self.nineml_outlet_ports.iteritems():
            ports[ daeGetRelativeName(parent, port) ] = port
        for sub_comp in self.nineml_subcomponents:
            ports.update(sub_comp._getOutletPorts(parent))
        return ports

    def _getReducePorts(self, parent):
        ports = {}
        for (name, port) in self.nineml_reduce_ports.iteritems():
            ports[ daeGetRelativeName(parent, port) ] = port
        for sub_comp in self.nineml_subcomponents:
            ports.update(sub_comp._getReducePorts(parent))
        return ports
    
    """
    def findPort(self, relativeName):
        ports = self._addAllPorts(self)
        print(ports)
        
        if relativeName in ports:
            return ports[relativeName]
        return None
    """
    
    def _getExpressionParserIdentifiers(self):
        dictIdentifiers = {}
        dictFunctions   = {}
        
        dictIdentifiers['pi'] = Constant(math.pi)
        dictIdentifiers['e']  = Constant(math.e)
        dictIdentifiers['t']  = Time()
        
        for parameter in self.Parameters:
            dictIdentifiers[parameter.Name] = parameter

        for variable in self.Variables:
            dictIdentifiers[variable.Name] = variable

        # Standard math. functions (single argument)
        dictFunctions['__create_constant__'] = Constant
        dictFunctions['sin']   = Sin
        dictFunctions['cos']   = Cos
        dictFunctions['tan']   = Tan
        dictFunctions['asin']  = ASin
        dictFunctions['acos']  = ACos
        dictFunctions['atan']  = ATan
        dictFunctions['sinh']  = Sinh
        dictFunctions['cosh']  = Cosh
        dictFunctions['tanh']  = Tanh
        dictFunctions['asinh'] = ASinh
        dictFunctions['acosh'] = ACosh
        dictFunctions['atanh'] = ATanh
        dictFunctions['log10'] = Log10
        dictFunctions['log']   = Log
        dictFunctions['sqrt']  = Sqrt
        dictFunctions['exp']   = Exp
        dictFunctions['floor'] = Floor
        dictFunctions['ceil']  = Ceil
        dictFunctions['fabs']  = Abs

        # Non-standard functions (multiple arguments)
        dictFunctions['pow']   = Pow

        # Random distributions, non-standard functions
        # Achtung!! Should be used only in StateAssignments statements
        dictFunctions['random.uniform']     = random_uniform
        dictFunctions['random.normal']      = random_normal
        dictFunctions['random.binomial']    = random_binomial
        dictFunctions['random.poisson']     = random_poisson
        dictFunctions['random.exponential'] = random_exponential

        return daetoolsVariableParameterDictionaryWrapper(dictIdentifiers), dictFunctions        
    
    def _generatePortConnectionEquation(self, varFrom, varTo):
        print(varFrom, varTo)

        fromIsDistributed = len(varFrom.Domains) > 0
        toIsDistributed   = len(varTo.Domains)   > 0
        
        eq = self.CreateEquation('port_connection_{0}_{1}'.format(varFrom.Name, varTo.Name), "")
        if fromIsDistributed and (not toIsDistributed):
            n = eq.DistributeOn(varFrom.Domains[0], eClosedClosed)
            eq.Residual = varFrom(n) - varTo()
            
        elif (not fromIsDistributed) and (not toIsDistributed):
            eq.Residual = varFrom() - varTo()
        
        elif fromIsDistributed and toIsDistributed:
            if varFrom.Domains[0].CanonicalName != varTo.Domains[0].CanonicalName:
                raise RuntimeError('')
            n = eq.DistributeOnDomain(varFrom.Domains[0], eClosedClosed)
            eq.Residual = varFrom(n) - varTo(n)
            print('port_connection', repr(varFrom(n) - varTo(n)))
        
        else:
            raise RuntimeError('Cannot generate a port connection equation for the port connection {0} -> {1}'.format(varFrom.CanonicalName, varTo.CanonicalName))

    def _generateReducePortConnectionEquation(self, source_variables, target_variable):
        eq = self.CreateEquation('reduce_port_connection_{0}'.format(target_variable.Name), "")
        
        if len(target_variable.Domains) > 0:
            n = eq.DistributeOnDomain(target_variable.Domains[0], eClosedClosed)
            residual = target_variable(n)
            for source_variable in source_variables:
                if len(source_variable.Domains) > 0:
                    residual = residual - source_variable(n)
                else:
                    raise RuntimeError('')

        else:
            residual = target_variable()
            for source_variable in source_variables:
                if len(source_variable.Domains) > 0:
                    nr = daeIndexRange(source_variable.Domains[0])
                    residual = residual - self.sum(source_variable.array(nr))
                else:
                    residual = residual - source_variable()
        
        print('reduce_port_connection', repr(residual))
        eq.Residual = residual
        
    def DeclareEquations(self):
        wrapperIdentifiers, dictFunctions = self._getExpressionParserIdentifiers()
        
        # 1a) Create aliases (algebraic equations)
        for (name, (var, num)) in self.nineml_aliases.iteritems():
            eq = self.CreateEquation(name, "")
            if self.N:
                n = eq.DistributeOnDomain(self.N, eClosedClosed)
                wrapperIdentifiers.current_index = n
                residual = var(n) - num.Node.evaluate(wrapperIdentifiers, dictFunctions)
            else:
                wrapperIdentifiers.current_index = None
                residual = var() - num.Node.evaluate(wrapperIdentifiers, dictFunctions)
            eq.Residual = residual
            print('Alias', repr(residual))
            
        # 1b) Create equations for ordinary analogue port connections
        for (varFrom, varTo) in self.nineml_port_connections:
            self._generatePortConnectionEquation(varFrom, varTo)
        
        # 1c) Create equations for reduce port connections
        for (name, (target_variable, source_variables)) in self.nineml_reduce_port_connections.iteritems():
            self._generateReducePortConnectionEquation(source_variables, target_variable)

        # 2) Create regimes
        if len(self.info.nineml_regimes) > 0:
            for stn_i in range(0, self.Nitems):
                # 2a) Create STN for model
                stn = self.STN('{0}({1})'.format(nineml_daetools_bridge.ninemlSTNRegimesName, stn_i))
                self.nineml_stns.append(stn)

                for (regime_name, odes, on_conditions, on_events) in self.info.nineml_regimes:
                    # 2b) Create State for each regime
                    self.STATE(regime_name)

                    # 2c) Create equations for all state variables/time derivatives
                    for (var_name, num) in odes:
                        if not var_name in self.nineml_variables:
                            raise RuntimeError('Cannot find state variable {0}'.format(var_name))
                        variable = self.nineml_variables[var_name]

                        eq = self.CreateEquation('ODE_{0}'.format(var_name), "")
                        if self.N:
                            #n = eq.DistributeOnDomain(self.N, eClosedClosed)
                            wrapperIdentifiers.current_index = stn_i
                            residual = variable.dt(stn_i) - num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                        
                        else:
                            wrapperIdentifiers.current_index = None
                            residual = variable.dt() - num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                        
                        eq.Residual = residual
                        print('ODE', repr(residual))
                            
                    # 2d) Create on_condition actions
                    for (condition_num, switch_to, set_variable_values, trigger_events) in on_conditions:
                        condition         = condition_num.CondNode.evaluate(wrapperIdentifiers, dictFunctions)
                        triggerEvents     = []
                        setVariableValues = []

                        for (var_name, num) in set_variable_values:
                            if not var_name in self.nineml_variables:
                                raise RuntimeError('Cannot find state variable {0}'.format(var_name))
                            variable = self.nineml_variables[var_name]
                            if self.N:
                                wrapperIdentifiers.current_index = stn_i
                                expression = num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                            else:
                                wrapperIdentifiers.current_index = None
                                expression = num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                            setVariableValues.append( (variable, expression) )
                            print('setVariableValues', repr(expression))

                        for (port_name, value) in trigger_events:
                            if not port_name in self.nineml_outlet_event_ports:
                                raise RuntimeError('Cannot find event port {0}'.format(port_name))
                            event_port = self.nineml_outlet_event_ports[port_name][stn_i]
                            triggerEvents.append( (event_port, value) )

                        self.ON_CONDITION(condition, switchTo          = switch_to,
                                                     setVariableValues = setVariableValues,
                                                     triggerEvents     = triggerEvents)

                    # 2e) Create on_event actions
                    for (source_port_name, switch_to_states, set_variable_values, trigger_events) in on_events:
                        if not source_port_name in self.nineml_inlet_event_ports:
                            raise RuntimeError('Cannot find event port {0}'.format(source_port_name))
                        source_event_port = self.nineml_inlet_event_ports[source_port_name][stn_i]
                        
                        switchToStates    = []
                        triggerEvents     = []
                        setVariableValues = []

                        for (var_name, num) in set_variable_values:
                            if not var_name in self.nineml_variables:
                                raise RuntimeError('Cannot find state variable {0}'.format(var_name))
                            variable = self.nineml_variables[var_name]
                            if self.N:
                                wrapperIdentifiers.current_index = stn_i
                                expression = num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                            else:
                                wrapperIdentifiers.current_index = None
                                expression = num.Node.evaluate(wrapperIdentifiers, dictFunctions)
                            setVariableValues.append( (variable, expression) )
                            print('setVariableValues', repr(expression))

                        for (port_name, value) in trigger_events:
                            if not port_name in self.nineml_outlet_event_ports:
                                raise RuntimeError('Cannot find event port {0}'.format(port_name))
                            event_port = self.nineml_outlet_event_ports[port_name][stn_i]
                            triggerEvents.append( (event_port, value) )

                        self.ON_EVENT(source_event_port, switchToStates    = switchToStates,
                                                         setVariableValues = setVariableValues,
                                                         triggerEvents     = triggerEvents)
                                                    
                self.END_STN()
    
class dae_component_setup:
    """
    Sets the parameter values, initial conditions and other processing needed,
    without a need for the separate object to wrap it.
    It defines two functions which are used by the simulation:
    
    * SetUpParametersAndDomains
    * SetUpVariables
    """
    _random_number_generators = {}
    
    @staticmethod
    def SetUpParametersAndDomains(model, parameters):
        dae_parameters = model._getParameters(model)
        
        if model.N.NumberOfPoints == 0:
            model.N.CreateArray(model.Nitems)
            print('Model = {0} N = {1}'.format(model.CanonicalName, model.N.NumberOfPoints))
        
        for paramCanonicalName, parameter in dae_parameters.iteritems():
            if not paramCanonicalName in parameters:
                raise RuntimeError('Could not find a value for the parameter {0}'.format(paramCanonicalName))
            
            value = parameters[paramCanonicalName]
            
            if isinstance(value, tuple) and isinstance(value[0], (long, int, float)):
                v = dae_component_setup.getValue(value, paramCanonicalName)
                if len(parameter.Domains) == 0:
                    parameter.SetValue(v)
                else:
                    parameter.SetValues(v)
            
            elif isinstance(value, tuple) and isinstance(value[0], nineml.user_layer.RandomDistribution):
                rng = dae_component_setup.getValue(value, paramCanonicalName)
                if len(parameter.Domains) == 0:
                    v = float(rng.next())
                    parameter.SetValue(v)
                else:
                    n = parameter.Domains[0].NumberOfPoints
                    for i in xrange(0, n):
                        v = float(rng.next())
                        parameter.SetValue(i, v)
            
            else:
                raise RuntimeError('Invalid parameter: {0} value type specified: {1}-{2}'.format(paramCanonicalName, value, type(value)))
    
    @staticmethod      
    def SetUpVariables(model, parameters, report_variables):
        dae_variables = model._getStateVariables(model)
        dae_aliases   = model._getAliases(model)
        
        for varCanonicalName, variable in dae_variables.iteritems():
            if not varCanonicalName in parameters:
                raise RuntimeError('Could not find an initial condition for the variable {0}'.format(varCanonicalName))
            
            value = parameters[varCanonicalName]
            
            if isinstance(value, tuple) and isinstance(value[0], (long, int, float)):
                v = dae_component_setup.getValue(value, varCanonicalName)
                if len(variable.Domains) == 0:
                    variable.SetInitialCondition(v)
                else:
                    variable.SetInitialConditions(v)
            
            elif isinstance(value, tuple) and isinstance(value[0], nineml.user_layer.RandomDistribution):
                rng = dae_component_setup.getValue(value, varCanonicalName)
                if len(variable.Domains) == 0:
                    v = float(rng.next())
                    variable.SetValue(v)
                else:
                    n = variable.Domains[0].NumberOfPoints
                    for i in xrange(0, n):
                        v = float(rng.next())
                        variable.SetInitialCondition(i, v)
            
            else:
                raise RuntimeError('Invalid state variable: {0} initial consition type specified: {1}-{2}'.format(varCanonicalName, value, type(value)))
        
        for varCanonicalName in report_variables:
            if varCanonicalName in dae_variables:
                variable = dae_variables[varCanonicalName]
                variable.ReportingOn = True
            elif varCanonicalName in dae_aliases:
                variable = dae_aliases[varCanonicalName]
                variable.ReportingOn = True
    
    @staticmethod
    def getValue(value, name):
        """
        Internal function used to get a value of parameters values and initial conditions.
        It can handle simple numbers and tuples (value, units). The *value* can be a simple number, 
        an expression involving other parameters and variables or a random number distribution.
        
        :rtype: float
        :raises: RuntimeError
        """
        if isinstance(value, tuple):
            if len(value) != 2:
                raise RuntimeError('The value for: {0} must be a tuple in the format (float, units): {1}'.format(name, value))
            
            _value, _units = value
            
            if isinstance(_value, (float, int, long)): # Simple number
                return float(_value)
            
            elif isinstance(_value, nineml.user_layer.RandomDistribution): # A RandomDistribution component
                if not _value.name in self._random_number_generators:
                    raise RuntimeError('Cannot find RandomDistribution component {0}'.format(_value.name))
                
                rng = dae_component_setup._random_number_generators[_value.name]
                return rng
            
            else: # Something is wrong
                raise RuntimeError('Invalid parameter: {0} value type specified: {1}-{2}'.format(name, value, type(value)))
        
        else:
            raise RuntimeError('Invalid parameter: {0} value type specified: {1}-{2}'.format(name, value, type(value)))

class dae_component_simulation(daeSimulation):
    """
    nineml_daetools_simulation carries out the simulation of the given (top level) model.
    Used only for simulation of the single AL component (wrapped into the nineml_daetools_bridge object),
    by the NineML WebApp and nineml_desktop_app.
    """
    def __init__(self, model, parameters, report_variables, timeHorizon, reportingInterval, random_number_generators):
        """
        Initializes nineml_daetools_simulation object.
        
        :param model: nineml_daetools_bridge object
        :param **kwargs: python dictionaries containing parameters values, initial conditions, reporting interval, time horizon, etc
        
        :rtype: None
        :raises: RuntimeError
        """
        daeSimulation.__init__(self)
        
        self.parameters        = parameters 
        self.report_variables  = report_variables
        self.TimeHorizon       = timeHorizon
        self.ReportingInterval = reportingInterval
        self.m                 = model
        
        dae_component_setup._random_number_generators = random_number_generators
    
    def SetUpParametersAndDomains(self):
        """
        Sets the parameter values. Called automatically by the simulation.
        
        :rtype: None
        :raises: RuntimeError
        """
        dae_component_setup.SetUpParametersAndDomains(self.m, self.parameters)
        
    def SetUpVariables(self):
        """
        Sets the initial conditions and other stuff. Called automatically by the simulation.
        
        :rtype: None
        :raises: RuntimeError
        """
        dae_component_setup.SetUpVariables(self.m, self.parameters, self.report_variables)

if __name__ == "__main__":
    al_component  = TestableComponent('hierachical_iaf_1coba')()
    if not al_component:
        raise RuntimeError('Cannot load NineML component')
    
    info = al_component_info('hierachical_iaf_1coba', al_component)
    #print(info)
    
    dae_comp = dae_component(info, 2, 'hierachical_iaf_1coba', None, '')
    dae_comp.initialize()
    #print(dae_comp)
    
    parameters = {
        "iaf.gl":         (   1E-8, "S"), 
        "iaf.vreset":     ( -0.060, "V"), 
        "iaf.taurefrac":  (  0.001, "s"), 
        "iaf.vthresh":    ( -0.040, "V"), 
        "iaf.vrest":      ( -0.060, "V"), 
        "iaf.cm":         ( 0.2E-9, "F"),
        
        "cobaExcit.vrev": (  0.000, "V"), 
        "cobaExcit.q":    ( 4.0E-9, "S"), 
        "cobaExcit.tau":  (  0.005, "s"), 
        
        "iaf.tspike":     (-1.00,   "s"), 
        "iaf.V":          (-0.045,  "V"), 
        "cobaExcit.g":    ( 0.00,   "S")
    }
    
    report_variables = ["cobaExcit.I", "iaf.V"] 
    
    # Create Log, Solver, DataReporter and Simulation object
    log          = daeBaseLog()
    daesolver    = daeIDAS()
    datareporter = daeTCPIPDataReporter()
    simulation   = dae_component_simulation(dae_comp, parameters, report_variables, 1.0, 0.01, {})
    
    #from daetools.solvers import pySuperLU as superlu
    #lasolver = superlu.daeCreateSuperLUSolver()
    #daesolver.SetLASolver(lasolver)

    # Connect data reporter
    simName = simulation.m.Name + strftime(" [%d.%m.%Y %H:%M:%S]", localtime())
    if(datareporter.Connect("", simName) == False):
        sys.exit()

    #simulation.m.SetReportingOn(True)

    # Initialize the simulation
    simulation.Initialize(daesolver, datareporter, log)

    # Solve at time=0 (initialization)
    simulation.SolveInitial()

    # Run
    simulation.Run()
    simulation.Finalize()
